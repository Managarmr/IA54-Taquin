package utbm.ia54.projet.^agent

import io.sarl.core.AgentTask
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.UUID
import utbm.ia54.projet.message.AggressionMessage
import utbm.ia54.projet.message.AskSynchroMessage
import utbm.ia54.projet.message.BecomeLeader
import utbm.ia54.projet.message.ExchangeMessage
import utbm.ia54.projet.message.ExchangeResponse
import utbm.ia54.projet.message.FindBlank
import utbm.ia54.projet.message.FindGoal
import utbm.ia54.projet.message.FleeAggressionMessage
import utbm.ia54.projet.message.IsEveryoneSynchro
import utbm.ia54.projet.message.IsSynchro
import utbm.ia54.projet.message.KillMessage
import utbm.ia54.projet.message.LeaderAggressionMessage
import utbm.ia54.projet.message.LogMessage
import utbm.ia54.projet.message.MoveDone
import utbm.ia54.projet.message.PathMessage
import utbm.ia54.projet.message.PlacedOn
import utbm.ia54.projet.message.SynchroResponse
import utbm.ia54.projet.message.sendAggro
import utbm.ia54.projet.message.sendFindBlank
import utbm.ia54.projet.message.sendFindGoal

agent EcoTileTest extends EcoAgentTest {

	uses Lifecycle, DefaultContextInteractions, Schedules, InnerContextAccess
	
	var isLeader = false
	var isAggressing = false
	var isBlankTile : boolean
	var aggressorID : UUID
	
	on Initialize {
		// Initialize parameters
		tileGoal = occurrence.parameters.get(0) as Integer
		puzzleSize = occurrence.parameters.get(1) as Integer
		isBlankTile = tileGoal == puzzleSize*puzzleSize
	}
	
	on PlacedOn {
		synchronizeWith(occurrence.idPlace)
	}
	
	
//	Synchro with place
	
	var synchroTask : AgentTask
	
	on Synchro{
		isSynchro = true
		if(isLeader) live
		if(isBlankTile )emit(new MoveDone)
	}
	
	def synchronizeWith(id : UUID){
		isSynchro = false
		idLinked = null
		position = null
		synchroTask = task("synchro with place")
		synchroTask.every(200)[
			emit(new AskSynchroMessage(ID, tileGoal, isLeader), Scopes.addresses(defaultSpace.getAddress(id)))
		]
	}
	on SynchroResponse{
		idLinked = occurrence.idPlace
		position = occurrence.position
		fireSynchro
	}
	
	def fireSynchro{
		if(synchroTask !== null) synchroTask.cancel
		innerContext.defaultSpace.emit(new Synchro)
	}
	
	
	on IsEveryoneSynchro[isSynchro]{
		emit(new IsSynchro(this.ID))
	}	
	
	// test exchange with blank
	
	on ExchangeMessage{
		emit(new ExchangeResponse(idLinked), Scopes.addresses(defaultSpace.getAddress(occurrence.idTile)))
		synchronizeWith(occurrence.idPlace)
	}
	
	on ExchangeResponse{
		synchronizeWith(occurrence.idPlace)
	}
	

//test aggression
	var taskAggro : AgentTask
	
	def aggress(target : UUID){
		isAggressing = true
		taskAggro = task("aggression")
		taskAggro.every(200)[
			var evt = new AggressionMessage
			evt.aggressorID = this.ID
			emit(evt, Scopes.addresses(defaultSpace.getAddress(target)))
		]
	}
	
	def aggressForBlank(path : ArrayList<UUID>){
		isAggressing = true
		taskAggro = task("aggression")
		println
		println(tileGoal + " " + position)
		for(p as UUID : path){
			println(p)
		}
		taskAggro.every(200)[
			var evt = new FleeAggressionMessage
			var pathEvt = path.clone as ArrayList<UUID>
			var target = pathEvt.remove(pathEvt.size-1)
			evt.aggressorID = this.ID
			evt.path = pathEvt
			emit(evt, Scopes.addresses(defaultSpace.getAddress(target)))
		]
	}
	
	def aggressForGoal(path : ArrayList<UUID>){
		isAggressing = true
		taskAggro = task("aggression")
		println
		for(p as UUID : path){
			println(p)
		}
		taskAggro.every(200)[
			var evt = new LeaderAggressionMessage
			evt.aggressorID = this.ID
			var target = path.get(path.size-1)
			emit(evt, Scopes.addresses(defaultSpace.getAddress(target)))
		]
	}
	
	def stopAggression{
		isAggressing = false
		if(taskAggro !== null) taskAggro.cancel
//		innerContext.defaultSpace.emit(new SynchroAggro)
	}
	
	on ExchangeMessage[isAggressing]{
		stopAggression
	}
	
	on AggressionMessage[isSynchro && isBlankTile]{
		emit(new ExchangeMessage(this.idLinked, this.ID), Scopes.addresses(defaultSpace.getAddress(occurrence.aggressorID)))
	}
	
	on FleeAggressionMessage[isSynchro && !isBlankTile && taskAggro === null]{
		aggressorID = occurrence.aggressorID
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForBlank(path)
	}
	
	on LeaderAggressionMessage[isSynchro && !isBlankTile && taskAggro === null]{
		aggressorID = occurrence.aggressorID
		emit(new FindBlank(this.ID))
	}
	
	on PathMessage[!isAggressing && !isLeader]{
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForBlank(path)
	}
	
	on PathMessage[!isAggressing && isLeader]{
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForGoal(path)
	}
	
	on BecomeLeader{
		if(occurrence.tileGoal == tileGoal){
			isLeader = true
			live
		}
	}	
	
	def live{
		if(isLeader){
			if(tileGoal != position){
				emit(new FindGoal(this.ID, this.tileGoal))
			}
			else{
				state = SatisfactionState.SATISFIED
				println(this.tileGoal + " is Satisfied")
				isLeader = false
				var nextLeader = computeNextLeader
				if(nextLeader != 0){
					emit(new BecomeLeader(nextLeader))
				}
			}
		}
	}
	
	def computeNextLeader : int{
		if(!isBlankTile){
			var xPos = (tileGoal-1)%puzzleSize
			var yPos = (tileGoal-xPos-1)/puzzleSize
			// on est en train de placer les tuiles de la ligne supérieure
			if(xPos > yPos){
				xPos--;
			}
			// on place les tuiles de la colone gauche
			else if(yPos < puzzleSize-1){
				yPos++;
			}
			else {
				yPos = xPos+1
				xPos = puzzleSize-1
			}
			return yPos*puzzleSize+xPos +1
		}
		else{
			return 0
		}
	}
	
	//debug
	//TODO à supprimer quand le débug sera fini
	on LogMessage{
		println("Tile : id : posFinale : " + tileGoal + " | pos " + position + " | ID Tile : " + ID)
	}
	
	on KillMessage{
		killMe
	}
	
	on sendFindBlank{
		emit(new FindBlank(this.ID))
	}
	
	on sendFindGoal{
		emit(new FindGoal(this.ID, this.tileGoal))
	}
	
	on sendAggro{
//		var evt = new LeaderAggressionMessage
//		evt.aggressorID = this.ID
//		emit(evt, Scopes.addresses(defaultSpace.getAddress(occurrence.target)))
		aggress(occurrence.target)
	}
	
	on sendFleeAggro{
		aggressForBlank(occurrence.path)
	}
	
	on sendExchange{
		emit(new ExchangeMessage(idLinked, this.ID), Scopes.addresses(defaultSpace.getAddress(occurrence.target)))
	}

	
}

event Synchro

event SynchroAggro

event sendFleeAggro{
	val aggressorID : UUID
	val path : ArrayList<UUID>
	new(aggressorID : UUID, path : ArrayList<UUID>){
		this.aggressorID = aggressorID
		this.path = path
	}
}
event sendExchange{
	val target : UUID
	new(target : UUID){
		this.target = target
	}
}