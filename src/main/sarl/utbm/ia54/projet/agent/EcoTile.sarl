package utbm.ia54.projet.^agent

import io.sarl.core.AgentTask
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.UUID
import utbm.ia54.projet.message.AggressionMessage
import utbm.ia54.projet.message.AskSynchroMessage
import utbm.ia54.projet.message.BecomeLeader
import utbm.ia54.projet.message.BecomeSatisfied
import utbm.ia54.projet.message.ExchangeMessage
import utbm.ia54.projet.message.ExchangeResponse
import utbm.ia54.projet.message.FindBlank
import utbm.ia54.projet.message.FindGoal
import utbm.ia54.projet.message.FleeAggressionMessage
import utbm.ia54.projet.message.IsEveryoneSynchro
import utbm.ia54.projet.message.IsSynchro
import utbm.ia54.projet.message.KillMessage
import utbm.ia54.projet.message.LeaderAggressionMessage
import utbm.ia54.projet.message.LogMessage
import utbm.ia54.projet.message.PathMessage
import utbm.ia54.projet.message.PlacedOn
import utbm.ia54.projet.message.SatisfiedResponse
import utbm.ia54.projet.message.SynchroResponse
import utbm.ia54.projet.message.sendFindBlank
import utbm.ia54.projet.message.sendFindGoal

agent EcoTile extends EcoAgent{

	uses Lifecycle, DefaultContextInteractions, Schedules, InnerContextAccess
	
	var isLeader = false
	var isAggressing = false
	var isBlankTile : boolean
	
	on Initialize {
		// Initialize parameters
		tileGoal = occurrence.parameters.get(0) as Integer
		puzzleSize = occurrence.parameters.get(1) as Integer
		isBlankTile = tileGoal == puzzleSize*puzzleSize
	}
	
	on PlacedOn {
		synchronizeWith(occurrence.idPlace)
	}
	
//	Synchro with place
	
	var synchroTask : AgentTask
	
	def synchronizeWith(id : UUID){
		isSynchro = false
		idLinked = null
		position = null
		synchroTask = task("synchro with place")
		synchroTask.every(200)[
			emit(new AskSynchroMessage(ID, tileGoal), Scopes.addresses(defaultSpace.getAddress(id)))
		]
	}
	
	on SynchroResponse{
		idLinked = occurrence.idPlace
		position = occurrence.position
		stopSynchroLoop
	}
	
	def stopSynchroLoop{
		if(synchroTask !== null) synchroTask.cancel
		isSynchro = true
		if(isLeader) live
		if(isBlankTile) emit(new LogMessage)
	}
	
	on IsEveryoneSynchro[isSynchro]{
		emit(new IsSynchro(this.ID))
	}	
	
	// test exchange with blank
	on ExchangeMessage{	
		stopAggression
		emit(new ExchangeResponse(idLinked), Scopes.addresses(defaultSpace.getAddress(occurrence.idTile)))
		synchronizeWith(occurrence.idPlace)
	}
	
	on ExchangeResponse{
		synchronizeWith(occurrence.idPlace)
	}
	

//test aggression
	var taskAggro : AgentTask
	
	def aggressForBlank(path : ArrayList<UUID>){
		isAggressing = true
		taskAggro = task("aggression")
		taskAggro.every(200)[
			var pathEvt = path.clone as ArrayList<UUID>
			var target = pathEvt.remove(pathEvt.size-1)
			emit(new FleeAggressionMessage(this.ID, pathEvt), Scopes.addresses(defaultSpace.getAddress(target)))
		]
	}
	
	def aggressForGoal(path : ArrayList<UUID>){
		isAggressing = true
		taskAggro = task("aggression")
		taskAggro.every(200)[
			var target = path.get(path.size-1)
			emit(new LeaderAggressionMessage(this.ID), Scopes.addresses(defaultSpace.getAddress(target)))
		]
	}
	
	def stopAggression{
		isAggressing = false
		if(taskAggro !== null) taskAggro.cancel
	}
	
	on AggressionMessage[isSynchro && isBlankTile]{
		emit(new ExchangeMessage(this.idLinked, this.ID), Scopes.addresses(defaultSpace.getAddress(occurrence.aggressorID)))
	}
	
	on FleeAggressionMessage[isSynchro && !isBlankTile && isAggressing == false]{
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForBlank(path)
	}
	
	on LeaderAggressionMessage[isSynchro && !isBlankTile && isAggressing == false]{
		emit(new FindBlank(this.ID))
	}
	
	on PathMessage[!isAggressing && !isLeader]{
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForBlank(path)
	}
	
	on PathMessage[!isAggressing && isLeader]{
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForGoal(path)
	}
	
	on BecomeLeader[occurrence.tileGoal == this.tileGoal]{
		isLeader = true
		live
	}	
	
	def live{
		if(tileGoal != position){
			emit(new FindGoal(this.ID, this.tileGoal))
		}
		else{
			becomeSatisfied
		}
	}
	
	def computeNextLeader : int{
		var nextLeader = 0
		if(!isBlankTile){
			var xPos = (tileGoal-1)%puzzleSize
			var yPos = (tileGoal-xPos-1)/puzzleSize
			// on est en train de placer les tuiles de la ligne supérieure
			if(xPos > yPos){
				xPos--;
			}
			// on place les tuiles de la colone gauche
			else if(yPos < puzzleSize-1){
				yPos++;
			}
			else {
				yPos = xPos+1
				xPos = puzzleSize-1
			}
			nextLeader = yPos*puzzleSize+xPos +1
		}
		if(nextLeader == puzzleSize*puzzleSize){
			nextLeader = 0
		}
		return nextLeader
		
	}
	
	on SatisfactionSynchro{
		isLeader = false
		var nextLeader = computeNextLeader
		if(nextLeader != 0)	emit(new BecomeLeader(nextLeader))
	}
	
	//synchro satisfaction 
	var taskSatisfying : AgentTask
	
	def becomeSatisfied{
		this.state = SatisfactionState.SATISFIED
		taskSatisfying = task("synchronizing satisfaction state")
		taskSatisfying.every(200)[
			emit(new BecomeSatisfied, Scopes.addresses(defaultSpace.getAddress(this.idLinked)))
		]
	}
	
	on SatisfiedResponse{
		if(taskSatisfying !== null) taskSatisfying.cancel
		fireSatisfactionSynchro
	}
	
	def fireSatisfactionSynchro{
		innerContext.defaultSpace.emit(new SatisfactionSynchro)
	}
	
	//debug
	//TODO à supprimer quand le débug sera fini
	on LogMessage{
		println("Tile : id : posFinale : " + tileGoal + " | pos " + position + " | ID Tile : " + ID)
	}
	
	on KillMessage{
		killMe
	}
	
	on sendFindBlank{
		emit(new FindBlank(this.ID))
	}
	
	on sendFindGoal{
		emit(new FindGoal(this.ID, this.tileGoal))
	}
	
	on sendFleeAggro{
		aggressForBlank(occurrence.path)
	}
	
	on sendExchange{
		emit(new ExchangeMessage(idLinked, this.ID), Scopes.addresses(defaultSpace.getAddress(occurrence.target)))
	}

	
}

event Synchro

event SynchroAggro

event SatisfactionSynchro

//débug

event sendFleeAggro{
	val aggressorID : UUID
	val path : ArrayList<UUID>
	new(aggressorID : UUID, path : ArrayList<UUID>){
		this.aggressorID = aggressorID
		this.path = path
	}
}
event sendExchange{
	val target : UUID
	new(target : UUID){
		this.target = target
	}
}

