package utbm.ia54.projet.^agent

import io.sarl.core.AgentTask
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.UUID
import utbm.ia54.projet.message.AggressionMessage
import utbm.ia54.projet.message.AskSynchroMessage
import utbm.ia54.projet.message.BecomeLeader
import utbm.ia54.projet.message.ExchangeMessage
import utbm.ia54.projet.message.ExchangeResponse
import utbm.ia54.projet.message.FindBlank
import utbm.ia54.projet.message.FindGoal
import utbm.ia54.projet.message.FleeAggressionMessage
import utbm.ia54.projet.message.IsEveryoneSynchro
import utbm.ia54.projet.message.IsSynchro
import utbm.ia54.projet.message.KillMessage
import utbm.ia54.projet.message.LeaderAggressionMessage
import utbm.ia54.projet.message.LogMessage
import utbm.ia54.projet.message.MoveDone
import utbm.ia54.projet.message.PathMessage
import utbm.ia54.projet.message.PlacedOn
import utbm.ia54.projet.message.SynchroResponse
import utbm.ia54.projet.message.sendAggro
import utbm.ia54.projet.message.sendFindBlank
import utbm.ia54.projet.message.sendFindGoal

agent EcoTile extends EcoAgent{

	uses Lifecycle, DefaultContextInteractions, Schedules, InnerContextAccess
	
	var isLeader = false
	var isAggressing = false
	var isBlankTile : boolean
	
	on Initialize {
		// Initialize parameters
		tileGoal = occurrence.parameters.get(0) as Integer
		puzzleSize = occurrence.parameters.get(1) as Integer
		isBlankTile = tileGoal == puzzleSize*puzzleSize
	}
	
	on PlacedOn {
		synchronizeWith(occurrence.idPlace)
	}
	
	
//	Synchro with place
	
	var synchroTask : AgentTask
	
	on Synchro{
		isSynchro = true
		if(isBlankTile )emit(new MoveDone)
		if(isLeader) live
	}
	
	def synchronizeWith(id : UUID){
		isSynchro = false
		idLinked = null
		position = null
		synchroTask = task("synchro with place")
		synchroTask.every(200)[
			emit(new AskSynchroMessage(ID, tileGoal, isLeader), Scopes.addresses(defaultSpace.getAddress(id)))
		]
	}
	on SynchroResponse{
		idLinked = occurrence.idPlace
		position = occurrence.position
		fireSynchro
	}
	
	def fireSynchro{
		if(synchroTask !== null) synchroTask.cancel
		innerContext.defaultSpace.emit(new Synchro)
	}
	
	
	on IsEveryoneSynchro[isSynchro]{
		emit(new IsSynchro(this.ID))
	}	
	
	// test exchange with blank
	
	on ExchangeMessage{	
		stopAggression
		emit(new ExchangeResponse(idLinked), Scopes.addresses(defaultSpace.getAddress(occurrence.idTile)))
		synchronizeWith(occurrence.idPlace)
	}
	
	on ExchangeResponse{
		synchronizeWith(occurrence.idPlace)
	}
	

//test aggression
	var taskAggro : AgentTask
	
	def aggress(target : UUID){
		isAggressing = true
		taskAggro = task("aggression")
		taskAggro.every(200)[
			var evt = new AggressionMessage
			evt.aggressorID = this.ID
			emit(evt, Scopes.addresses(defaultSpace.getAddress(target)))
		]
	}
	
	def aggressForBlank(path : ArrayList<UUID>){
		isAggressing = true
		taskAggro = task("aggression")
		println
		println(tileGoal + " " + position)
		for(p as UUID : path){
			println(p)
		}
		taskAggro.every(200)[
			var evt = new FleeAggressionMessage
			var pathEvt = path.clone as ArrayList<UUID>
			var target = pathEvt.remove(pathEvt.size-1)
			evt.aggressorID = this.ID
			evt.path = pathEvt
			emit(evt, Scopes.addresses(defaultSpace.getAddress(target)))
		]
	}
	
	def aggressForGoal(path : ArrayList<UUID>){
		isAggressing = true
		taskAggro = task("aggression")
		println
		for(p as UUID : path){
			println(p)
		}
		taskAggro.every(200)[
			var evt = new LeaderAggressionMessage
			evt.aggressorID = this.ID
			var target = path.get(path.size-1)
			emit(evt, Scopes.addresses(defaultSpace.getAddress(target)))
		]
	}
	
	def stopAggression{
		isAggressing = false
		if(taskAggro !== null) taskAggro.cancel
//		innerContext.defaultSpace.emit(new SynchroAggro)
	}
	
	on AggressionMessage[isSynchro && isBlankTile]{
		emit(new ExchangeMessage(this.idLinked, this.ID), Scopes.addresses(defaultSpace.getAddress(occurrence.aggressorID)))
	}
	
	on FleeAggressionMessage[isSynchro && !isBlankTile && isAggressing == false]{
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForBlank(path)
	}
	
	on LeaderAggressionMessage[isSynchro && !isBlankTile && isAggressing == false]{
		emit(new FindBlank(this.ID))
	}
	
	on PathMessage[!isAggressing && !isLeader]{
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForBlank(path)
	}
	
	on PathMessage[!isAggressing && isLeader]{
		var path = occurrence.path.clone as ArrayList<UUID>
		aggressForGoal(path)
	}
	
	on BecomeLeader[occurrence.tileGoal == this.tileGoal]{
		println("on BecomeLeader " + this.tileGoal)
		isLeader = true
		live
	}	
	
	on SatisfactionSynchro{
		println(this.tileGoal + " is Satisfied")
		isLeader = false
		var nextLeader = computeNextLeader
		if(nextLeader != 0){
			emit(new BecomeLeader(nextLeader))
		}
	}
	
	def live{
		println("start live " + this.tileGoal)
		if(isLeader){
			if(tileGoal != position){
				emit(new FindGoal(this.ID, this.tileGoal))
			}
			else{
				state = SatisfactionState.SATISFIED
				println(this.tileGoal + " is Satisfied")
				isLeader = false
				var nextLeader = computeNextLeader
				if(nextLeader != 0){
					emit(new BecomeLeader(nextLeader))
				}
			}
		}
	}
	
	def computeNextLeader : int{
		var nextLeader = 0
		if(!isBlankTile){
			var xPos = (tileGoal-1)%puzzleSize
			var yPos = (tileGoal-xPos-1)/puzzleSize
			// on est en train de placer les tuiles de la ligne supérieure
			if(xPos > yPos){
				xPos--;
			}
			// on place les tuiles de la colone gauche
			else if(yPos < puzzleSize-1){
				yPos++;
			}
			else {
				yPos = xPos+1
				xPos = puzzleSize-1
			}
			nextLeader = yPos*puzzleSize+xPos +1
		}
		if(nextLeader == puzzleSize*puzzleSize){
			nextLeader = 0
		}
		return nextLeader
		
	}
	
	//synchro satisfying 
	var taskSatisfying : AgentTask
	def BecomeSatisfied{
		this.state = SatisfactionState.SATISFIED
		taskSatisfying = task("synchronizing satisfaction state")
		taskSatisfying.every(200)[
			emit(new BecomeSatisfied, Scopes.addresses(defaultSpace.getAddress(this.idLinked)))
		]
	}
	
	on SatisfiedResponse{
		if(taskSatisfying !== null) taskSatisfying.cancel
		fireSatisfactionSynchro
	}
	
	def fireSatisfactionSynchro{
		innerContext.defaultSpace.emit(new SatisfactionSynchro)
	}
	
	//debug
	//TODO à supprimer quand le débug sera fini
	on LogMessage{
		println("Tile : id : posFinale : " + tileGoal + " | pos " + position + " | ID Tile : " + ID)
	}
	
	on KillMessage{
		killMe
	}
	
	on sendFindBlank{
		emit(new FindBlank(this.ID))
	}
	
	on sendFindGoal{
		emit(new FindGoal(this.ID, this.tileGoal))
	}
	
	on sendAggro{
//		var evt = new LeaderAggressionMessage
//		evt.aggressorID = this.ID
//		emit(evt, Scopes.addresses(defaultSpace.getAddress(occurrence.target)))
		aggress(occurrence.target)
	}
	
	on sendFleeAggro{
		aggressForBlank(occurrence.path)
	}
	
	on sendExchange{
		emit(new ExchangeMessage(idLinked, this.ID), Scopes.addresses(defaultSpace.getAddress(occurrence.target)))
	}

	
}

event Synchro

event SynchroAggro

event sendFleeAggro{
	val aggressorID : UUID
	val path : ArrayList<UUID>
	new(aggressorID : UUID, path : ArrayList<UUID>){
		this.aggressorID = aggressorID
		this.path = path
	}
}
event sendExchange{
	val target : UUID
	new(target : UUID){
		this.target = target
	}
}

event BecomeSatisfied

event SatisfiedResponse

event SatisfactionSynchro