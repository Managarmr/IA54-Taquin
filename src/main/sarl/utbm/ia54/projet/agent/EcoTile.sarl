package utbm.ia54.projet.^agent

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.UUID
import utbm.ia54.projet.message.AggressionMessage
import utbm.ia54.projet.message.AskSynchroMessage
import utbm.ia54.projet.message.BecomeLeader
import utbm.ia54.projet.message.ExchangeMessage
import utbm.ia54.projet.message.ExchangeResponse
import utbm.ia54.projet.message.FindBlank
import utbm.ia54.projet.message.FindGoal
import utbm.ia54.projet.message.FledMessage
import utbm.ia54.projet.message.FleeAggressionMessage
import utbm.ia54.projet.message.IsEveryoneSynchro
import utbm.ia54.projet.message.IsSynchro
import utbm.ia54.projet.message.KillMessage
import utbm.ia54.projet.message.LeaderAggressionMessage
import utbm.ia54.projet.message.LogMessage
import utbm.ia54.projet.message.PathMessage
import utbm.ia54.projet.message.PlacedOn
import utbm.ia54.projet.message.SynchroResponse
import utbm.ia54.projet.message.sendAggro
import utbm.ia54.projet.message.sendFindBlank
import utbm.ia54.projet.message.sendFindGoal

agent EcoTile extends EcoAgent {

	uses Lifecycle, DefaultContextInteractions
	
	var posFinale : Integer
	var isLeader : boolean
	var isSynchro : boolean
	
	on Initialize {
		// Initialize parameters
		posFinale = occurrence.parameters.get(0) as Integer
		puzzleSize = occurrence.parameters.get(1) as Integer
		isSynchro = false
		isLeader = false
		state = SatisfactionState.UNSATISFIED
	}
	
	//synchro with place
	on PlacedOn {
		while(posFinale === null){}
		synchronizingWith(occurrence.id)
	}
	
	on AskSynchroMessage {
		idLinked = occurrence.id
		pos = occurrence.pos
		emit(new SynchroResponse(ID,posFinale),Scopes.addresses(defaultSpace.getAddress(idLinked)))
		
	}
	
	on SynchroResponse{
		idLinked = occurrence.id
		pos = occurrence.pos
	}
	
	on IsEveryoneSynchro{
		if(isSynchro){
			emit(new IsSynchro(this.ID))
		}
	}	
	
	def synchronizingWith(id : UUID){
		idLinked = null
		pos = null
		emit(new AskSynchroMessage(ID,pos), Scopes.addresses(defaultSpace.getAddress(id)))
		while(idLinked === null || pos === null){
			Thread.sleep(500)
			emit(new AskSynchroMessage(ID,posFinale), Scopes.addresses(defaultSpace.getAddress(id)))
		}
		isSynchro = true
	}
	
	
	
	//leading
	on BecomeLeader{
		if (occurrence.position == posFinale){
			isLeader = true
		}
	}
	
	
	
	def computeNextLeader : int{
		var xPos = (posFinale%puzzleSize) -1
		var yPos = (posFinale-xPos-1)/puzzleSize
		// on est en train de placer les tuiles de la ligne supérieure
		if(xPos > yPos){
			xPos--;
		}
		// on place les tuiles de la colone gauche
		else {
			yPos++;
		}
		return yPos*puzzleSize+xPos +1
	}
	
	
	//exchange place with blank
	on ExchangeMessage{
		isSynchro = false
		var evt = new ExchangeResponse(this.idLinked)
		evt.source = defaultSpace.getAddress(this.ID)
		emit(evt, Scopes.addresses(occurrence.source))
		
		synchronizingWith(occurrence.idPlace)
		if(aggresseurID !== null){
			Thread.sleep(2000)
			emit(new FledMessage(occurrence.idTile), Scopes.addresses(defaultSpace.getAddress(aggresseurID)))
//			aggresseurID = null
		}
	}
	
	on ExchangeResponse{
		synchronizingWith(occurrence.idPlace)
		
	}
	
	//debug
	//TODO à supprimer quand le débug sera fini
	on LogMessage{
		println("Tile : id : " + ID + " | posFinale : " + posFinale + " | pos " + pos)
//		killMe
	}
	
	on KillMessage{
		killMe
	}
	
	on sendFindBlank{
		emit(new FindBlank(this.ID))
	}
	
	on sendFindGoal{
		emit(new FindGoal(this.ID, this.posFinale))
	}
	
	on sendAggro{
		var evt = new LeaderAggressionMessage
		evt.aggresseurID = this.ID
		emit(evt, Scopes.addresses(defaultSpace.getAddress(occurrence.target)))
	}

//test
var aggresseurID : UUID
on FleeAggressionMessage{
	if(posFinale!=this.puzzleSize*this.puzzleSize){
		this.aggresseurID = occurrence.aggresseurID
		var path = occurrence.path.clone as ArrayList<UUID>
		var evt = new FleeAggressionMessage
		evt.aggresseurID = this.ID
		evt.path = path
		emit(evt, Scopes.addresses(defaultSpace.getAddress(path.remove(path.size-1))))		
	}
}

on LeaderAggressionMessage{
	if(posFinale != puzzleSize*puzzleSize){
		aggresseurID = occurrence.aggresseurID
		emit(new FindBlank(this.ID))
	}
}

on AggressionMessage{
	if(posFinale == puzzleSize*puzzleSize){
		emit(new ExchangeMessage(this.idLinked, this.ID),Scopes.addresses(defaultSpace.getAddress(occurrence.aggresseurID)))
	}
}
on PathMessage{
	var path = occurrence.path.clone as ArrayList<UUID>
	for(p as UUID : path){
		println(p)
	}
	if(aggresseurID === null){
		var evt = new LeaderAggressionMessage
		var target = path.remove(path.size-1)
		evt.aggresseurID = this.ID
		println(this.ID + " aggresse : " + target)
		emit(evt,Scopes.addresses(defaultSpace.getAddress(target)))
	}
	else{
		var evt = new FleeAggressionMessage
		evt.aggresseurID = this.ID
		var target = path.remove(path.size-1)
		evt.path = path
		println(this.ID + " aggresse : " + target)
		emit(evt,Scopes.addresses(defaultSpace.getAddress(target)))
	}
}

on FledMessage{
	println(this.ID + " Fled")
	var evt = new AggressionMessage
	evt.aggresseurID = this.ID
	emit(evt, Scopes.addresses(defaultSpace.getAddress(occurrence.idBlankTile)))
}

	
}