//package utbm.ia54.projet.^agent
//
//import io.sarl.core.Behaviors
//import io.sarl.core.DefaultContextInteractions
//import io.sarl.core.Destroy
//import io.sarl.core.Initialize
//import io.sarl.core.Lifecycle
//import io.sarl.core.Logging
//import io.sarl.core.Schedules
//import io.sarl.util.Scopes
//import java.util.ArrayList
//import java.util.HashSet
//import java.util.UUID
//import utbm.ia54.projet.message.BecomeLeader
//import utbm.ia54.projet.message.FledMessage
//import utbm.ia54.projet.message.IsEveryoneSynchro
//import utbm.ia54.projet.message.IsSynchro
//import utbm.ia54.projet.message.KillMessage
//import utbm.ia54.projet.message.LogMessage
//import utbm.ia54.projet.message.MoveDone
//import utbm.ia54.projet.message.PlacedOn
//
//agent EcoNPuzzleTest {
//	
//	uses DefaultContextInteractions, Lifecycle, Logging,Behaviors, Schedules
//	
//	var size : int
//	var tiles = new ArrayList<UUID>
//	var places = new ArrayList<UUID>
//		
////*
//	on Initialize {
//		size = new Integer(occurrence.parameters.get(0) as String)
//		
//		initializePuzzle
//		
//		synchro
//		
//		emit(new BecomeLeader(size))
//		
////		emit(new LogMessage)
////		emit(new sendExchange(tiles.get(1)), Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
////		emit(new sendAggro(tiles.get(3)), Scopes.addresses(defaultSpace.getAddress(tiles.get(2))))
////		var path = new ArrayList<UUID>
////		path.add(places.get(3))
////		path.add(places.get(2))
////		emit(new PathMessage(path), Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
////		emit(new sendFindBlank,Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
////		var evt = new LeaderAggressionMessage
////		evt.aggressorID = tiles.get(0)
////		emit(evt, Scopes.addresses(defaultSpace.getAddress(tiles.get(1))))
////		emit(new sendFindGoal, Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
////		synchro
//		
////		emit(new LogMessage)
////		emit(new BecomeLeader(size))
////		emit(new sendAggro(tiles.get(3)),Scopes.addresses(defaultSpace.getAddress(tiles.get(2))))
////		emit(new sendFindBlank, Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
////		emit(new sendFindGoal, Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
//
////		// Stop creating
////		killMe
//	}	
//
////initializing
//	def initializePuzzle{
//		var spacesId = new ArrayList<UUID>
//		for(i:0..<size*size){
//			spacesId.add(UUID.randomUUID)
//		}
//		
//		for(i:0..<size*size) {
//			//get communication spaces
//			var temp = new ArrayList<UUID>
//			if(i >= size){
//				temp.add(spacesId.get(i-size))
//			}
//			if(i < size*(size-1)){
//				temp.add(spacesId.get(i+size))
//			}
//			if(i%size != 0){
//				temp.add(spacesId.get(i-1))
//			}
//			if(i%size != size-1){
//				temp.add(spacesId.get(i+1))
//			}
//			// Create place and tile
//			places.add(spawn(EcoPlaceTest, i+1, size, spacesId.get(i), temp))
//			tiles.add(spawn(EcoTileTest, i+1, size))
//		}
//		
//		while(defaultSpace.participants.size < (size*size*2)+1){
//		}
//		println("creation done")
//		
//		var tempTiles = tiles.clone as ArrayList<UUID>
//		emit(new PlacedOn(places.get(0)), Scopes.addresses(defaultSpace.getAddress(tiles.get(5))))
//		emit(new PlacedOn(places.get(1)), Scopes.addresses(defaultSpace.getAddress(tiles.get(6))))
//		emit(new PlacedOn(places.get(2)), Scopes.addresses(defaultSpace.getAddress(tiles.get(1))))
//		emit(new PlacedOn(places.get(3)), Scopes.addresses(defaultSpace.getAddress(tiles.get(7))))
//		emit(new PlacedOn(places.get(4)), Scopes.addresses(defaultSpace.getAddress(tiles.get(2))))
//		emit(new PlacedOn(places.get(5)), Scopes.addresses(defaultSpace.getAddress(tiles.get(4))))
//		emit(new PlacedOn(places.get(6)), Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
//		emit(new PlacedOn(places.get(7)), Scopes.addresses(defaultSpace.getAddress(tiles.get(3))))
//		emit(new PlacedOn(places.get(8)), Scopes.addresses(defaultSpace.getAddress(tiles.get(8))))
////		for(i:0..<size*size){
////			var ind = (Math.random * (tempTiles.size-1)) as int
////			var tile = tempTiles.get(ind)
////			tempTiles.remove(ind)
//////			var tile = tiles.get(i)
////			emit(new PlacedOn(places.get(i)), Scopes.addresses(defaultSpace.getAddress(tile)))
////		}	
//		
//		println("placing done")
//	}
//	
//	
//	on MoveDone{ 	
//		println
//		emit(new LogMessage)
////		killMe
//	}
//	
//	//synchronize
//	var synchroTiles = new HashSet<UUID>
//	
//	on IsSynchro{
//		synchroTiles.add(occurrence.tileId)
//	}
//	
//	def synchro{
//		synchroTiles.clear
//		var evt = new IsEveryoneSynchro
//		emit(evt)
//		while(!synchroTiles.containsAll(tiles)){
//			emit(evt)
//			Thread.sleep(500)
//		}
//		println("synchronizing done")
//	}
//	
//	on Destroy{
//		emit(new KillMessage)
//	}
//	
//	on FledMessage{
//		emit(new LogMessage)
//		killMe
//	}
//}