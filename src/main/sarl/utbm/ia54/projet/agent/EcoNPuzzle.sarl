package utbm.ia54.projet.^agent

import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.HashSet
import java.util.UUID
import utbm.ia54.projet.message.BecomeLeader
import utbm.ia54.projet.message.IsEveryoneSynchro
import utbm.ia54.projet.message.IsSynchro
import utbm.ia54.projet.message.KillMessage
import utbm.ia54.projet.message.PlacedOn

agent EcoNPuzzle {
	
	uses DefaultContextInteractions, Lifecycle, Logging,Behaviors, Schedules
	
	var size : int
	var tiles = new ArrayList<UUID>
	var places = new ArrayList<UUID>
		
//*
	on Initialize {
		size = new Integer(occurrence.parameters.get(0) as String)
		
		initializePuzzle
		
		synchro
		
		emit(new BecomeLeader(size))
		
	}	

//initializing
	def initializePuzzle{
		var spacesId = new ArrayList<UUID>
		for(i:0..<size*size){
			spacesId.add(UUID.randomUUID)
		}
		
		for(i:0..<size*size) {
			//get communication spaces
			var temp = new ArrayList<UUID>
			if(i >= size){
				temp.add(spacesId.get(i-size))
			}
			if(i < size*(size-1)){
				temp.add(spacesId.get(i+size))
			}
			if(i%size != 0){
				temp.add(spacesId.get(i-1))
			}
			if(i%size != size-1){
				temp.add(spacesId.get(i+1))
			}
			// Create place and tile
			places.add(spawn(EcoPlace, i+1, size, spacesId.get(i), temp))
			tiles.add(spawn(EcoTile, i+1, size))
		}
		
		while(defaultSpace.participants.size < (size*size*2)+1){
		}
		println("creation done")
		
		var tempTiles = tiles.clone as ArrayList<UUID>
		emit(new PlacedOn(places.get(0)), Scopes.addresses(defaultSpace.getAddress(tiles.get(5))))
		emit(new PlacedOn(places.get(1)), Scopes.addresses(defaultSpace.getAddress(tiles.get(6))))
		emit(new PlacedOn(places.get(2)), Scopes.addresses(defaultSpace.getAddress(tiles.get(1))))
		emit(new PlacedOn(places.get(3)), Scopes.addresses(defaultSpace.getAddress(tiles.get(7))))
		emit(new PlacedOn(places.get(4)), Scopes.addresses(defaultSpace.getAddress(tiles.get(2))))
		emit(new PlacedOn(places.get(5)), Scopes.addresses(defaultSpace.getAddress(tiles.get(4))))
		emit(new PlacedOn(places.get(6)), Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
		emit(new PlacedOn(places.get(7)), Scopes.addresses(defaultSpace.getAddress(tiles.get(3))))
		emit(new PlacedOn(places.get(8)), Scopes.addresses(defaultSpace.getAddress(tiles.get(8))))
//		for(i:0..<size*size){
//			var ind = (Math.random * (tempTiles.size-1)) as int
//			var tile = tempTiles.get(ind)
//			tempTiles.remove(ind)
////			var tile = tiles.get(i)
//			emit(new PlacedOn(places.get(i)), Scopes.addresses(defaultSpace.getAddress(tile)))
//		}	
		
		println("placing done")
	}
	
	//synchronize
	var synchroTiles = new HashSet<UUID>
	
	on IsSynchro{
		synchroTiles.add(occurrence.tileId)
	}
	
	def synchro{
		synchroTiles.clear
		var evt = new IsEveryoneSynchro
		emit(evt)
		while(!synchroTiles.containsAll(tiles)){
			emit(evt)
			Thread.sleep(500)
		}
		println("synchronizing done")
	}
	
	on Destroy{
		emit(new KillMessage)
	}
}