package utbm.ia54.projet.^agent

import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.HashSet
import java.util.UUID
import utbm.ia54.projet.message.IsEveryoneSynchro
import utbm.ia54.projet.message.IsSynchro
import utbm.ia54.projet.message.KillMessage
import utbm.ia54.projet.message.LogMessage
import utbm.ia54.projet.message.PlacedOn
import utbm.ia54.projet.message.sendFindBlank
import utbm.ia54.projet.message.showPath

agent EcoNPuzzle {
	
	uses DefaultContextInteractions, Lifecycle, Logging,Behaviors
	
	var size : int
	var tiles = new ArrayList<UUID>
	var places = new ArrayList<UUID>
		
//debug
/*
	on Initialize {
		size = new Integer(occurrence.parameters.get(0) as String)
		var spaceId = new ArrayList<UUID>
		for(i:0..<size*size){
			spaceId.add(UUID.randomUUID)
		}
		
//		var tiles = new ArrayList<UUID>
//		var places = new ArrayList<UUID>
		
		
		for(i:1..<size*size +1) {
			//get communication spaces
			var temp = new ArrayList<UUID>
			if(i > size){
				temp.add(spaceId.get(i-size-1))
			}
			if(i <= size*(size-1)){
				temp.add(spaceId.get(i+size-1))
			}
			if(i%size != 1){
				temp.add(spaceId.get(i-2))
			}
			if(i%size != 0){
				temp.add(spaceId.get(i))
			}
			// Create place and tile
			places.add(spawn(EcoPlace, i, size, spaceId.get(i-1), temp))
			tiles.add(spawn(EcoTile, i, size))
			emit(new PlacedOn(places.get(i-1)),Scopes.addresses(defaultSpace.getAddress(tiles.get(i-1))))
		}
//		for(i:1..<size*size+1){
//			emit(new PlacedOn(places.get(i-1)),Scopes.addresses(defaultSpace.getAddress(tiles.get(i-1))))
//		}
		synchro
		emit(new LogMessage)
//		emit(new sendFindBlank, Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
//		Thread.sleep(2000)
//		emit(new showPath, Scopes.addresses(defaultSpace.getAddress(places.get(0))))

		// Stop creating
		killMe
	}
	
//*/

//*	
	on Initialize {
		size = new Integer(occurrence.parameters.get(0) as String)
		var spaceId = new ArrayList<UUID>
		for(i:0..<size*size){
			spaceId.add(UUID.randomUUID)
		}
		
		
		for(i:1..<size*size+1) {
			//get communication spaces
			var temp = new ArrayList<UUID>
			temp.clear
			if(i > size){
				temp.add(spaceId.get(i-size-1))
			}
			if(i < size*(size-1)){
				temp.add(spaceId.get(i+size-1))
			}
			if(i%size != 1){
				temp.add(spaceId.get(i-2))
			}
			if(i%size != 0){
				temp.add(spaceId.get(i))
			}
			
			// Create place and tile
			places.add(spawn(EcoPlace, i, size, spaceId.get(i-1), temp))
			tiles.add(spawn(EcoTile, i, size))
		}
		var placesTemp = places.clone as ArrayList<UUID>
		for(t as UUID : tiles){
			var p = placesTemp.remove(Math.floor(Math.random * placesTemp.size) as int)
			emit(new PlacedOn(p), Scopes.addresses(defaultSpace.getAddress(t)))
		}
		synchro
		emit(new LogMessage)
		emit(new sendFindBlank, Scopes.addresses(defaultSpace.getAddress(tiles.get(0))))
		Thread.sleep(2000)
		emit(new showPath, Scopes.addresses(defaultSpace.getAddress(places.get(0))))
		
		// Launch GUI
//		EcoNPuzzleLauncher.launchInterface()
		
		// Stop creating
		killMe
	}
//*/
	
	//synchronize
	var synchroTiles = new HashSet<UUID>
	
	on IsSynchro{
		synchroTiles.add(occurrence.tileId)
	}
	
	def synchro{
		synchroTiles.clear
		while(!synchroTiles.containsAll(tiles)){
			emit(new IsEveryoneSynchro)
			Thread.sleep(500)
		}
	}
	
	on Destroy{
		emit(new KillMessage)
	}
}